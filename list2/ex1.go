package main

import (
	"fmt"
	"io/ioutil"
	"os"

	bst "github.com/me/Compression-and-Methods-of-Coding/binary_search_tree"
	bits "github.com/me/Compression-and-Methods-of-Coding/bits"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func main() {
	if len(os.Args) < 3 {
		fmt.Printf("Missing some arguments, correct form is: %s <input_file> <output_file>", os.Args[0])
	}

	// Reading file to calculate Huffman Tree
	data, err := ioutil.ReadFile(os.Args[1])
	check(err)

	repetitions := make(map[byte]float64)
	counter := float64(len(data))

	for _, symbol := range data {
		repetitions[symbol]++
	}

	// calculate Huffman Tree
	compressedAlphabet := canonicalHuffman(repetitions, counter)

	bitString := ""
	bytesRes := make([]byte, 0)

	// parse symbols from input file into new alphabet generated by Huffman Tree
	for _, symbol := range data {
		bitString += compressedAlphabet[symbol]
		if len(bitString)%8 == 0 {
			bytesRes = append(bytesRes, bits.Bits2bytes(bitString)...)
			bitString = ""
		}
	}
	// there are no enough bits to fit into bytes (not an 8 iteration)
	if len(bitString) != 0 {
		for ok := true; ok; ok = (len(bitString) < 8) {
			bitString += "0"
		}
		bytesRes = append(bytesRes, bits.Bits2bytes(bitString)...)
	}

	fmt.Println(bytesRes)
}

func canonicalHuffman(reps map[byte]float64, counter float64) map[byte]string {

	// Parse map into array of nodes
	ns := make(bst.Nodes, 0, len(reps))
	for k, v := range reps {
		ns = append(ns, bst.MakeNode(v/counter, int16(k)))
	}

	// Make single Huffman Tree from array of nodes
	var newRoot, n1, n2 *bst.Node
	for fin := false; !fin; fin = (len(ns) == 1) {
		ns, n1, n2 = ns.Pop2Min()
		newRoot = bst.MakeNode(n1.Value+n2.Value, -1)
		newRoot.Left, newRoot.Right = n1, n2
		ns = append(ns, newRoot)
	}

	var makeBitsMap func(parent *bst.Node, codeWords map[byte]string)
	codeWords := make(map[byte]string)
	// assign new coding to each symbol
	makeBitsMap = func(parent *bst.Node, codeWords map[byte]string) {
		if parent.Symbol == -1 {
			parent.Left.Codeword = parent.Codeword + "0"
			parent.Right.Codeword = parent.Codeword + "1"
			makeBitsMap(parent.Left, codeWords)
			makeBitsMap(parent.Right, codeWords)
		} else if parent.Symbol != -2 {
			codeWords[byte(parent.Symbol)] = parent.Codeword
		}
	}

	makeBitsMap(ns[0], codeWords)

	return codeWords
}
